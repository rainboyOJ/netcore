#pragma once
#include <string>
#include <vector>
#include <string_view>

#include "define.h"

#include "epoll_server.hpp"
//#include "utils.hpp"
#include "connection.hpp"
#include "http_router.hpp"
////#include "router.hpp"
//#include "function_traits.hpp"
//#include "url_encode_decode.hpp"
#include "http_cache.hpp"
//#include "session_manager.hpp"
//#include "cookie.hpp"

namespace rojcpp {
    
    //cache
    template<typename T>
    struct enable_cache {
        enable_cache(T t) :value(t) {}
        T value;
    };

    using SocketType = int;

    class http_server_ : /*private noncopyable ,*/public epoll_server<connection> {
    public:
        using type = int; // fd is int
        http_server_() = default;

        void init(
        int port, int trigMode, int timeoutMS, bool OptLinger, 
        int sqlPort, const char* sqlUser, const  char* sqlPwd, 
        const char* dbName, int connPoolNum, int threadNum,
        bool openLog, int logLevel, int logQueSize
                )
        {
            __init__(port, trigMode, timeoutMS, OptLinger, sqlPort, sqlUser, sqlPwd, dbName, connPoolNum, threadNum, openLog, logLevel, logQueSize);
            http_cache::get().set_cache_max_age(86400); // 最大的cache时间
            init_conn_callback(); //初始化 连接的回掉函数 http_handler_ ,static_res_hander 静态资源hander
        }

// inherit virtual function 
    //有新的client来了 把它加入
    virtual void DealListen_() override {
        struct sockaddr_in addr;
        socklen_t len = sizeof(addr);
        do {
            int fd = accept(listenFd_, (struct sockaddr *)&addr, &len);
            if(fd <= 0) { return;}
            else if(HttpConn::userCount >= MAX_FD) {
                SendError_(fd, "Server busy!");
                LOG_WARN("Clients is full!");
                return;
            }
            AddClient_(fd, addr,
                    max_req_buf_size_, //max_req_size
                    keep_alive_timeout_, //keep_alive_timeout
                    http_handler_, // http_handler& handler
                    upload_dir_, //std::string& static_dir
                    upload_check_? &upload_check_ : nullptr // upload_check
                    );
                //io_service_pool_.get_io_service(), ssl_conf_, max_req_buf_size_, keep_alive_timeout_, http_handler_, upload_dir_,
                //upload_check_?&upload_check_ : nullptr
            //);
        } while(listenEvent_ & EPOLLET);
    }
    //当可以写的时候，写入
    virtual void DealWrite_(HttpConn* client);
    //读取 来的数据
    virtual void DealRead_(HttpConn* client);


        //void enable_http_cache(bool b) { // 开启 http_cache
            //http_cache::get().enable_cache(b);
        //}

        //void set_ssl_conf(ssl_configure conf) { // ssl 配置
            //ssl_conf_ = std::move(conf);
        //}

        //bool port_in_use(unsigned short port) { // 端口是否在使用
            ////TODO
        //}

        //void stop() { // 停止 服务器
            //io_service_pool_.stop();
        //}

        void run() { //启动服务器
            //init_dir(static_dir_); //初始化 路径 ?
            //init_dir(upload_dir_);
            Start(); //TODO call father class
        }


        // 设置静态文件的路径
        void set_static_dir(std::string path) { 
            set_file_dir(std::move(path), static_dir_);
        }

        //void set_upload_dir(std::string path) {
            //set_file_dir(std::move(path), upload_dir_);
        //}

        //const std::string& static_dir() const { //得到路径
            //return static_dir_;
        //}

        ////最大的返回的buffer 大小
        //void set_max_req_buf_size(std::size_t max_buf_size) {
            //max_req_buf_size_ = max_buf_size;
        //}

        ////保值连接的时间
        //void set_keep_alive_timeout(long seconds) {
            //keep_alive_timeout_ = seconds;
        //}

        template<typename T>
        bool need_cache(T&& t) { //需要cache ?
            if constexpr(std::is_same_v<T, enable_cache<bool>>) {
                return t.value;
            }
            else {
                return false;
            }
        }

        //set http handlers
        template<http_method... Is, typename Function, typename... AP>
        void set_http_handler(std::string_view name, Function&& f, AP&&... ap) {
            //只要AP里面有一个是 enable_cache<bool>类型
            if constexpr(has_type<enable_cache<bool>, std::tuple<std::decay_t<AP>...>>::value) {//for cache
                bool b = false;
                ((!b&&(b = need_cache(std::forward<AP>(ap)))),...); //折叠表达式
                if (!b) {
                    http_cache::get().add_skip(name); //TODO 核心是我不懂 http_cache 的作用
                }else{
                    http_cache::get().add_single_cache(name);
                }
                auto tp = filter<enable_cache<bool>>(std::forward<AP>(ap)...);
                auto lm = [this, name, f = std::move(f)](auto... ap) {
                    http_router_.register_handler<Is...>(name, std::move(f), std::move(ap)...);
                };
                std::apply(lm, std::move(tp));
            }
            else {
                http_router_.register_handler<Is...>(name, std::forward<Function>(f), std::forward<AP>(ap)...);
            }
        }

        //void set_res_cache_max_age(std::time_t seconds)
        //{
            //static_res_cache_max_age_ = seconds;
        //}

        //std::time_t get_res_cache_max_age()
        //{
            //return static_res_cache_max_age_;
        //}

        //void set_cache_max_age(std::time_t seconds)
        //{
            //http_cache::get().set_cache_max_age(seconds);
        //}

        //std::time_t get_cache_max_age()
        //{
            //return http_cache::get().get_cache_max_age();
        //}

        //void set_download_check(std::function<bool(request& req, response& res)> checker) { //下载检验
            //download_check_ = std::move(checker);
        //}

        ////should be called before listen
        //void set_upload_check(std::function<bool(request& req, response& res)> checker) { //上传检验
            //upload_check_ = std::move(checker);
        //}

        //void mapping_to_root_path(std::string relate_path) {
            //relate_paths_.emplace_back("."+std::move(relate_path));
        //}

        //void set_not_found_handler(std::function<void(request& req, response& res)> not_found) {
            //not_found_ = std::move(not_found);
        //}

        //void set_multipart_begin(std::function<void(request&, std::string&)> begin) {
            //multipart_begin_ = std::move(begin);
        //}

        //void set_validate(size_t max_header_len, check_header_cb check_headers) {
            //max_header_len_ = max_header_len;
            //check_headers_ = std::move(check_headers);
        //}

        //void enable_timeout(bool enable){
            //enable_timeout_ = enable;
        //}

        //void enable_response_time(bool enable) {
            //need_response_time_ = enable;
        //}

        //void set_transfer_type(transfer_type type) {
            //transfer_type_ = type;
        //}

        //void on_connection(std::function<bool(std::shared_ptr<connection<SocketType>>)> on_conn) {
            //on_conn_ = std::move(on_conn);
        //}

    //private:
        //void start_accept(std::shared_ptr<boost::asio::ip::tcp::acceptor> const& acceptor) { // 这里建立连接
            //auto new_conn = std::make_shared<connection<SocketType>>(   //创建了一个叫做 new_conn 的东西
                //io_service_pool_.get_io_service(), ssl_conf_, max_req_buf_size_, keep_alive_timeout_, http_handler_, upload_dir_,
                //upload_check_?&upload_check_ : nullptr
            //);

            //acceptor->async_accept(new_conn->tcp_socket(), [this, new_conn, acceptor](const int& e) {
                //if (!e) {
                    //new_conn->tcp_socket().set_option(boost::asio::ip::tcp::no_delay(true)); //做一些事情
                    //if (multipart_begin_) {
                        //new_conn->set_multipart_begin(multipart_begin_); // ?? 
                    //}
                    
                    //new_conn->enable_response_time(need_response_time_);
                    //new_conn->enable_timeout(enable_timeout_);

                    //if (check_headers_) { // 检查头部
                        //new_conn->set_validate(max_header_len_, check_headers_);
                    //}

                    //if (!on_conn_) { // 开始
                        //new_conn->start();                        
                    //}
                    //else {
                        //if (on_conn_(new_conn)) {
                            //new_conn->start();
                        //}
                    //}
                //}
                //else {
                    ////LOG_INFO << "server::handle_accept: " << e.message();
                //}

                //start_accept(acceptor);
            //});
        //}

        ////静态资源hander
        void set_static_res_handler()
        {
            set_http_handler<POST,GET>(STATIC_RESOURCE, [this](request& req, response& res){
                if (download_check_) {
                    bool r = download_check_(req, res);
                    if (!r) {
                        res.set_status_and_content(status_type::bad_request);
                        return;
                    }                        
                }

                auto state = req.get_state();
                switch (state) {
                    case rojcpp::data_proc_state::data_begin:
                    {
                        std::string relative_file_name = req.get_relative_filename();
                        std::string fullpath = static_dir_ + relative_file_name;

                        auto mime = req.get_mime(relative_file_name);
                        auto in = std::make_shared<std::ifstream>(fullpath, std::ios_base::binary);
                        if (!in->is_open()) {
                            if (not_found_) {
                                not_found_(req, res);
                                return;
                            }
                            res.set_status_and_content(status_type::not_found,"");
                            return;
                        }
                        auto start = req.get_header_value("cinatra_start_pos");
                        if (!start.empty()) {
                            std::string start_str(start);
                            int64_t start = (int64_t)atoll(start_str.data());
                            std::error_code code;
                            int64_t file_size = fs::file_size(fullpath, code);
                            if (start > 0 && !code && file_size >= start) {
                                in->seekg(start);
                            }
                        }
                        
                        req.get_conn<SocketType>()->set_tag(in);
                        
                        //if(is_small_file(in.get(),req)){
                        //    send_small_file(res, in.get(), mime);
                        //    return;
                        //}

                        if(transfer_type_== transfer_type::CHUNKED)
                            write_chunked_header(req, in, mime);
                        else
                            write_ranges_header(req, mime, fs::path(relative_file_name).filename().string(), std::to_string(fs::file_size(fullpath)));
                    }
                        break;
                    case rojcpp::data_proc_state::data_continue:
                    {
                        if (transfer_type_ == transfer_type::CHUNKED)
                            write_chunked_body(req);
                        else
                            write_ranges_data(req);
                    }
                        break;
                    case rojcpp::data_proc_state::data_end:
                    {
                        auto conn = req.get_conn<SocketType>();
                        conn->on_close();
                    }
                        break;
                    case rojcpp::data_proc_state::data_error:
                    {
                        //network error
                    }
                        break;
                }
            },enable_cache{false});
        }

        //bool is_small_file(std::ifstream* in,request& req) const {
            //auto file_begin = in->tellg();
            //in->seekg(0, std::ios_base::end);
            //auto  file_size = in->tellg();
            //in->seekg(file_begin);
            //req.save_request_static_file_size(file_size);
            //return file_size <= 5 * 1024 * 1024;
        //}

        //void send_small_file(response& res, std::ifstream* in, std::string_view mime) {
            //res.add_header("Access-Control-Allow-origin", "*");
            //res.add_header("Content-type", std::string(mime.data(), mime.size()) + "; charset=utf8");
            //std::stringstream file_buffer;
            //file_buffer << in->rdbuf();
            //if (static_res_cache_max_age_>0)
            //{
                //std::string max_age = std::string("max-age=") + std::to_string(static_res_cache_max_age_);
                //res.add_header("Cache-Control", max_age.data());
            //}
//#ifdef CINATRA_ENABLE_GZIP
            //res.set_status_and_content(status_type::ok, file_buffer.str(), res_content_type::none, content_encoding::gzip);
//#else
            //res.set_status_and_content(status_type::ok, file_buffer.str());
//#endif
        //}

        ////写入一个头
        void write_chunked_header(request& req, std::shared_ptr<std::ifstream> in, std::string_view mime) {
            auto range_header = req.get_header_value("range");
            req.set_range_flag(!range_header.empty());
            req.set_range_start_pos(range_header);

            std::string res_content_header = std::string(mime.data(), mime.size()) + "; charset=utf8";
            res_content_header += std::string("\r\n") + std::string("Access-Control-Allow-origin: *");
            res_content_header += std::string("\r\n") + std::string("Accept-Ranges: bytes");
            if (static_res_cache_max_age_>0)
            {
                std::string max_age = std::string("max-age=") + std::to_string(static_res_cache_max_age_);
                res_content_header += std::string("\r\n") + std::string("Cache-Control: ") + max_age;
            }
            
            if(req.is_range())
            {
                std::int64_t file_pos  = req.get_range_start_pos();
                in->seekg(file_pos);
                auto end_str = std::to_string(req.get_request_static_file_size());
                res_content_header += std::string("\r\n") +std::string("Content-Range: bytes ")+std::to_string(file_pos)+std::string("-")+std::to_string(req.get_request_static_file_size()-1)+std::string("/")+end_str;
            }
            req.get_conn<SocketType>()->write_chunked_header(std::string_view(res_content_header),req.is_range());
        }

        void write_chunked_body(request& req) {
            const size_t len = 3 * 1024 * 1024;
            auto str = get_send_data(req, len);
            auto read_len = str.size();
            bool eof = (read_len == 0 || read_len != len);
            req.get_conn<SocketType>()->write_chunked_data(std::move(str), eof);
        }

        void write_ranges_header(request& req, std::string_view mime, std::string filename, std::string file_size) {
            std::string header_str = "HTTP/1.1 200 OK\r\nAccess-Control-Allow-origin: *\r\nAccept-Ranges: bytes\r\n";
            header_str.append("Content-Disposition: attachment;filename=");
            header_str.append(std::move(filename)).append("\r\n");
            header_str.append("Connection: keep-alive\r\n");
            header_str.append("Content-Type: ").append(mime).append("\r\n");
            header_str.append("Content-Length: ");
            header_str.append(file_size).append("\r\n\r\n");
            req.get_conn<SocketType>()->write_ranges_header(std::move(header_str));
        }

        void write_ranges_data(request& req) {
            const size_t len = 3 * 1024 * 1024;
            auto str = get_send_data(req, len);
            auto read_len = str.size();
            bool eof = (read_len == 0 || read_len != len);
            req.get_conn<SocketType>()->write_ranges_data(std::move(str), eof);
        }

        std::string get_send_data(request& req, const size_t len) {
            auto conn = req.get_conn<SocketType>();
            auto in = std::any_cast<std::shared_ptr<std::ifstream>>(conn->get_tag());
            std::string str;
            str.resize(len);
            in->read(&str[0], len);
            size_t read_len = (size_t)in->gcount();
            if (read_len != len) {
                str.resize(read_len);
            }

            return str;
        }

        //important 初始化 connection 的callback
        void init_conn_callback() {
            set_static_res_handler();
            //http_handler_ = [this](request& req, response& res) { //这里初始化了 http_handler_
                //res.set_headers(req.get_headers());
                //try {
                    //bool success = http_router_.route(req.get_method(), req.get_url(), req, res);
                    //if (!success) {
                        //if (not_found_) {
                            //not_found_(req, res);
                            //return;
                        //}
                        //res.set_status_and_content(status_type::bad_request, "the url is not right");
                    //}
                //}
                //catch (const std::exception& ex) {
                    //res.set_status_and_content(status_type::internal_server_error, ex.what()+std::string(" exception in business function"));
                //}
                //catch (...) {
                    //res.set_status_and_content(status_type::internal_server_error, "unknown exception in business function");
                //}                
            //};
        }

        void set_file_dir(std::string&& path, std::string& dir) {
            
            //default: current path + "www"/"upload"
            //"": current path
            //"./temp", "temp" : current path + temp
            //"/temp" : linux path; "C:/temp" : windows path
            
            if (path.empty()) {
                dir = fs::current_path().string();
                return;
            }

            if (path[0] == '/' || (path.length() >= 2 && path[1] == ':')) {
                dir = std::move(path);
            }
            else {
                dir = fs::absolute(path).string();
            }
        }

        //void init_dir(const std::string& dir) {
            //std::error_code ec;
            //bool r = fs::exists(dir, ec);
            //if (ec) {
                //std::cout << ec.message();
            //}

            //if (!r) {
                //fs::create_directories(dir, ec);
                //if (ec) {
                    //std::cout << ec.message();
                //}
            //}
        //}

        std::size_t max_req_buf_size_ = 3 * 1024 * 1024; //max request buffer size 3M
        long keep_alive_timeout_ = 60; //max request timeout 60s

        http_router http_router_;
        std::string static_dir_ = fs::absolute("www").string(); //default
        std::string upload_dir_ = fs::absolute("www").string(); //default
        std::time_t static_res_cache_max_age_ = 0;

        bool enable_timeout_ = true;
        http_handler http_handler_ = nullptr;
        std::function<bool(request& req, response& res)> download_check_;
        std::vector<std::string> relate_paths_;
        std::function<bool(request& req, response& res)> upload_check_ = nullptr;

        std::function<void(request& req, response& res)> not_found_ = nullptr;
        std::function<void(request&, std::string&)> multipart_begin_ = nullptr;
        //std::function<bool(std::shared_ptr<connection<SocketType>>)> on_conn_ = nullptr; //作什么用的?

        size_t max_header_len_;
        check_header_cb check_headers_;

        transfer_type transfer_type_ = transfer_type::CHUNKED;
        bool need_response_time_ = false;
    };

    //template<typename T>
    //using http_server_proxy = http_server_<T, io_service_pool>;

    //using http_server = http_server_proxy<NonSSL>;
    //using http_ssl_server = http_server_proxy<SSL>;
}
